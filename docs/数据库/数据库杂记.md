## 简介

## 必备知识

### Mysql 执行计划

```sql
explain select 查询语句;
```

+ id：自增序号，还可用来标识“驱动表”
+ select_type：查询类型，SIMPLE代表直接对表的简单查询
+ table：查询哪张表
+ partitions：坐落分区，分区表一般不用，所以通常都是null
+ type：索引检索类型，const代表常数（只找到唯一的记录）查询，这个效率很高
+ prossble_keys：与当前查询相关备选的索引有哪些，PRIMARY代表主键
+ key：代表当前实际使用的索引是哪个
+ key_len：代表单个索引值的长度，一般为字段类型占用长度，例如long类型为8
+ ref：显示使用哪个列或常数与key一起从表中选择行。
+ rows：本次查询所扫描的行数，注意：这个值可能和最终结果不一致，扫描行数越少越好
+ filter：过滤器，公式：`rows * filtered * 100 ≈ 估算的查询结果`，这个不靠谱
+ extra：扩展条件的详细信息

## 记录

### 多表关联

阿里规范里明确禁止三表Join查询，在数据量大时，多表关联性能会急剧下降，但如果没有做架构上额外设计以及强制要求，该用join还是用join。

#### Hash Join

HashJoin可以改善大数据量Join时的性能，但代价是会消耗较大内存。

各个数据库对Join性能有差异，表现较好的有Oracle、PostgreSQL，这两个数据库都在一定程度上支持 Hash Join，MySql在8.0后也支持HashJoin

> [面试官：为什么你们项目中还在用多表关联！ - 掘金 (juejin.cn)](https://juejin.cn/post/7387626171158675466?searchId=20240706232710DFD0ED9FA028880CE6F5)
>
> [数据库引擎中的JOIN算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/663520935)

| 类别     | Nested Loop                                                  | Hash Join                                                    | Sort-Merge-Join                                              |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 使用条件 | 任何条件                                                     | 等值连接（=）。除非数据有严重倾斜                            | 等值或非等值连接(>，<，=，>=，<=)，‘<>’除外。                |
| 相关资源 | CPU、磁盘I/O                                                 | 内存、临时空间                                               | 内存、临时空间                                               |
| 特点     | 当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。 | 当缺乏索引或者索引条件模糊时，Hash Join比Nested Loop有效。通常比Merge Join快。在数据仓库环境下，如果表的纪录数多，效率高。 | 当缺乏索引或者索引条件模糊时，Merge Join比Nested Loop有效。非等值连接时，Merge Join比Hash Join更有效 |
| 缺点     | 当索引丢失或者查询条件限制不够时，效率很低；当表的纪录数多时，效率低。 | 为建立哈希表，需要大量内存。第一次的结果返回较慢。           | 所有的表都需要排序。它为最优化的吞吐量而设计，并且在结果没有全部找到前不返回数据。 |

MySql触发HashJoin条件参考官方文档：[MySQL :: WL#2241: Hash join](https://dev.mysql.com/worklog/task/?id=2241)

#### 反范式表

需要多表关联是因为想要筛选的数据存在多个表中，导致需要Join来关联计算，一个解决方法是引入冗余数据，减少表的关联。

优点：

1. 减少表的关联：通过引入冗余数据，可以减少查询时对多个表的关联需求，从而提高查询性能。
2. 更好的索引优化：允许一定程度的冗余有助于设计更有效的索引，进一步加快查询速度。

缺点：
1. 数据冗余及数据维护异常：反范式设计会增加数据冗余，这可能导致数据一致性维护的困难，以及数据维护成本增加（如删除异常、插入异常、更新异常）。
2. 对数据的修改需要更多的成本：由于存在冗余数据，对数据的修改需要更多的操作和考虑，以确保数据的一致性和准确性。

在实际应用中，反范式设计常用于数据仓库（OLAP）场景，其中查询分析是主要任务，通过牺牲一定程度的数据一致性来换取查询效率的提升。相比之下，在线事务处理（OLTP）系统则更倾向于遵循范式设计，以尽可能消除冗余，提高变更效率。



实际应用：开启数据库binlog，使用flink cdc 同步关联数据后冗余数据（大宽表）到 clickhouse、doris、elasticsearch，查询时直接查询冗余数据

#### 物化视图

> [物化视图是什么，物化视图和视图最大区别 - SelectDB](https://www.selectdb.com/blog/476)

物化视图是一个预先计算和存储的查询结果集，类似于一张物理表，但不同于物理表的是，它可以通过数据库的内部机制定期更新。物化视图可以看作是远程数据的本地副本，或者用于生成基于数据表求和的汇总表。

物化视图适合这类非实时查询，对一致性要求不高的场景

物化视图状况支持：

1. PostgreSQL
2. Doris
3. ClickHouse
4. Oracle

有些数据库物化视图还支持增量更新，MySQL数据库到8.4还不支持物化视图

**物化视图的主要功能包括：**

1. 提高查询性能：物化视图预先计算并存储查询结果，当查询请求到达时，可以直接返回结果，而无需重新计算，从而提高查询性能。
2. 减少查询开销：由于物化视图存储了查询结果，因此在查询时可以减少计算资源的消耗，降低查询开销。
3. 支持离线查询：物化视图可以在离线模式下使用，即使数据库不可用，也可以使用物化视图作为备份进行查询。

**物化视图的工作原理可以概括为以下几个步骤：**

1. 定义物化视图：用户根据自己的需求，定义物化视图的查询语句和数据存储方式。
2. 预先计算：系统根据物化视图的定义，预先计算出查询结果，并将结果存储在物化视图中。
3. 数据更新：当基表数据发生变化时，物化视图也需要进行更新，以确保数据的准确性。这通常通过数据库的刷新机制实现。
4. 查询优化：在查询过程中，系统会根据物化视图的存在和内容进行查询优化，提高查询效率。

**物化视图在以下场景中特别有用：**

1. 数据仓库：在数据仓库中，经常需要对大量数据进行复杂的查询和分析。使用物化视图可以预先计算和存储这些查询的结果，从而提高查询性能。
2. 实时数据分析：对于需要实时获取数据分析结果的应用场景，物化视图可以确保数据的实时性和准确性，同时提供快速的查询响应。
3. 大数据处理：在处理大数据时，物化视图可以作为一种缓存机制，将部分计算结果存储起来，以便在后续查询中重复使用，从而降低计算资源的消耗。
4. 复杂的表连接和聚合操作：对于涉及多个表连接和聚合操作的查询，物化视图可以将这些耗时的操作预先计算并存储起来，从而避免在每次查询时都重新执行这些操作。

### 左模糊

> 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
> 说明：索引文件具有B+Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

左模糊不走索引，这种情况一般的情况是建议引入搜索引擎（ES等）

但实际如果把数据同步到ES也是个不小的问题，对于这种情况有下面一些方法

#### 全文索引

MySQL5.6.24以后InnoDB引擎支持全文索引，可以在数据量不太大的时候，使用全文索引，注意默认情况下分词长度是2，对中文来说不能单字模糊匹配，如果要支持，就需要修改全局变量`ngram_token_size`（参考[【IT老齐055】MySQL模糊查询还在用like？Mysql Ngram全文检索技术快速上手_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1xv411G7Cv/?spm_id_from=333.788&vd_source=a7294b5d53441a33f427f8cd4d5333c2)）

全文索引基于倒排实现

全文索引需要使用专门的函数`MATCH()`和`AGAINST()`进行左右模糊查询，语法如下

```sql
MATCH(col1,col2,...) AGAINST(expr[search_modifier])
search_modifier:
{
    IN NATURAL LANGUAGE MODE
    | IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION
    | IN BOOLEAN MODE
    | WITH QUERY EXPANSION
}
```

更为具体的语法不做介绍

### 索引选择性陷阱

通俗地说，如果搜索条件命中过多数据，占总量一定比例以上（25%），**可能**就不会走索引搜索，而是走全表扫描，以Explain执行计划为准

#### 组合索引提高选择性

增加搜索条件，匹配更少的数据，简单地说就是多加点 where 条件

#### 引入搜索引擎

用 ES 等搜索引擎替代这类查询

#### 强制使用索引

可以强制使用字段索引，但不一定快，以实际为准

例如 `select * from user force index(name) where name = 'A'`

#### 增加缓存池大小

全表扫描慢一个原因是内存不足，不得不多次运算再合并结果，那么增加缓存大小可以增加全表扫描速度，配置如下

```
innodb_buffer_pool_size=16G
innodb_buffer_pool_instances=2
```



### 大页码查询

大页码查询有时即使加了索引，数据库也可能走全表扫描，例如

```sql
select  * from blog order_info order by create_time
LIMIT 500000,10;
```

sql优化器有可能认为走索引会比全表扫描慢，因此直接走了全表扫描

可以先进行覆盖索引查询，只查询排序字段

```sql
select * from order_info 
	where create_time >=
	(
     select create_time from order_info
        order by order_info limit 500000,1
    )
    order by create_time limit 10;
```

注：上面的方式只适用于 create_time无重复的情况，例如如果 499999 页面也有这个时间，则会查到 499999 页的数据，如果有自增 id，可以用自增 id（唯一自增均可）

### 大in查询
大 in 查询容易导致全表扫描，且不少数据库会有in数量限制
```sql
select * from user where id in(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66)
```

这个没有进行详细测试，可以按照下面思路尝试：

+ 如果in中数据是子查询结果，使用join替代 in 查询
+ 如果In数据是传入数据，尝试用union all拼接in中数据，生成临时表
+ 如果In数据是大量数据，可以分批次查询，每次查询少量数据，然后合并结果


## 参考

[【IT老齐022】阿里开发规范解读，为啥禁止三表Join关联？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1GA411A7gJ/?spm_id_from=333.788&vd_source=a7294b5d53441a33f427f8cd4d5333c2)

[数据库引擎中的JOIN算法 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/663520935)

[面试官：为什么你们项目中还在用多表关联！ - 掘金 (juejin.cn)](https://juejin.cn/post/7387626171158675466?searchId=20240706232710DFD0ED9FA028880CE6F5)

[物化视图是什么，物化视图和视图最大区别 - SelectDB](https://www.selectdb.com/blog/476)